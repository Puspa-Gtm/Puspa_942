<!DOCTYPE html>
<html>
<head>
    <title>Chapter 1 - Computer System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;700&display=swap');
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            text-align: justify;
            background: linear-gradient(135deg, #121212, #1c1c1c);
            color: #f5f5f5;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }
        .image{
            font-style: italic;
            font-family:Verdana, Geneva, Tahoma, sans-serif ;
            text-align: center;
            align-items: center;
        }
        .hero {
            background: url('ch1.jpg') no-repeat center center/cover;
            background-opacity: 70%;
            height: 70vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.7rem;
            font-weight: bold;
            text-shadow: 4px 4px 15px rgba(0, 0, 0, 0.8);
            animation: fadeInSlide 2s ease-in-out;

        }
        @keyframes fadeInSlide {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .nav {
            background: linear-gradient(90deg, #333, #555);
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 20px;
            border-bottom: 4px solid #222;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease-in-out;
        }
        .nav:hover {
            background: linear-gradient(90deg, #444, #666);
        }
        .nav a {
            color: white;
            text-decoration: none;
            font-size: 1.3rem;
            padding: 12px 18px;
            border-radius: 8px;
            transition: background 0.3s, transform 0.3s ease-in-out;
        }
        .nav a:hover {
            background-color: #444;
            transform: scale(1.1);
        }
        .content {
            padding: 60px;
            font-size: 1.4rem;
            line-height: 1.8;
            max-width: 1100px;
            margin: auto;
            background: #2a2a2a;
            border-radius: 12px;
            box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.15);
        }
        h2, h3 {
            color: #ffcc5c;
            margin-top: 20px;
        }
        p, ul {
            margin-bottom: 20px;
        }
        ul li {
            margin: 5px 0;
        }
        .footer {
            margin-top: 50px;
            background: linear-gradient(90deg, #222, #333);
            color: white;
            padding: 25px;
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
        }
    </style>
</head>
<body>
   
    <div class="hero">
       <h1>Chapter 1 - Database Management System</h1>
    </div>
    <div class="nav">
        <a href="index.html">Home</a>
        <a href="Ch-1.html">Chapter 1</a>
        <a href="Ch-2.html">Chapter 2</a>
        <a href="Ch-3.html">Chapter 3</a>
        <a href="Ch-4.html">Chapter 4</a>
        <a href="Ch-5.html">Chapter 5</a>
        <a href="Ch-6.html">Chapter 6</a>
        <a href="Ch-7.html">Chapter 7</a>
    </div>
    <div class="content">
       
   
              
        <h2>Data</h2>
        <p>
        Data consists of raw facts, figures, and symbols that are collected from various sources but have not yet been processed or interpreted. It can exist in many forms, such as numbers, text, images, audio, or video. Data on its own does not carry any meaning until it is analyzed or put into context. For example, a list of numbers like “105, 210, 350” is data—it does not tell us anything unless we know what those numbers represent. 
        </p>
        
        <h2>Information</h2>
        <p>
        Information is data that has been processed, organized, and structured in a way that adds meaning and context. It is data made useful and understandable for specific purposes, such as decision-making, problem-solving, or analysis. When we collect data and arrange it logically—like putting customer purchase records into a table, calculating totals, and visualizing trends—it becomes information.     </p>
        
        <h3>Features of Information</h3>
        <ul>
            <li><strong>Accuracy:</strong> Accurate information is free from errors and reflects the true state of facts. It helps in making reliable decisions.</li>
            <li><strong>Timeliness:</strong> Information must be available when it is needed. Outdated information can lead to incorrect decisions or missed opportunities.</li>
            <li><strong>Completeness:</strong> Complete information includes all the necessary data required to understand a situation fully and make informed decisions.</li>
            <li><strong>Relevance:</strong> Information must be directly related to the purpose or issue at hand. Irrelevant data, even if accurate, does not help.</li>
            <li><strong>Consistency:</strong> Information should be uniform and match other related data, ensuring there are no contradictions or discrepancies.</li>
        </ul>
        
        <h2>Database and Its Purpose</h2>
        <p>
        A database is a structured and organized collection of related data stored in a computer system. It allows data to be stored electronically in a way that it can be easily accessed, updated, and managed. The main purpose of a database is to store large volumes of data efficiently while minimizing redundancy and maximizing data integrity. Modern databases support multi-user environments, meaning many users can access and manipulate data simultaneously without conflict. Databases are essential for various applications—from online banking and inventory systems to e-commerce websites and healthcare systems.       </p>
        
        <h2>Terminologies in Database</h2>
        <ul>
            <li><strong>Table:</strong> A database object that holds data in a grid of rows and columns, where each table represents an entity such as customers, products, or orders.</li>
            <li><strong>Field:</strong> A column in a table that defines a specific type of data, such as a customer’s name, ID number, or phone number.</li>
            <li><strong>Record:</strong> A row in a table that represents one instance of the entity. For example, one customer's data forms one record.</li>
            <li><strong>Tuple:</strong> A synonym for a record; it refers to a single row in a relational database table.</li>
            <li><strong>Object:</strong> In object-oriented databases, an object is a self-contained unit that includes both data (attributes) and the methods (functions) that operate on the data.</li>
            <li><strong>Keys:</strong> Keys are special fields used to uniquely identify records or create relationships between tables. A <strong>Primary Key</strong> uniquely identifies each record in a table, while a <strong>Foreign Key</strong> links one table to another.</li>
        </ul>
        
        <h2>Data Dictionary</h2>
        <p>
        A data dictionary is a central source of information about the data in a database. It stores metadata—data about the actual data—such as the names of tables, the structure of fields, data types, field lengths, constraints, and relationships among tables. It acts like a reference guide for database developers, administrators, and users by ensuring everyone understands the structure and rules of the data. By maintaining consistency and documentation, a data dictionary helps prevent errors during database design, development, and maintenance. It is often built-in and maintained by the DBMS software itself.
        </p>
        
        <h2>Database Management System (DBMS)</h2>
        
        <h3>Introduction</h3>
        <p>
        A Database Management System (DBMS) is a software application that enables users to interact with a database to store, retrieve, manipulate, and manage data efficiently. It acts as a bridge between the user and the data stored in the database. With a DBMS, users can perform various operations such as inserting new data, updating existing records, deleting unnecessary data, and running queries to generate reports. It hides the complexities of how data is physically stored and allows users to focus on logical operations. Examples of DBMS software include MySQL, Oracle, PostgreSQL, and Microsoft SQL Server.
        </p>
        
        <h3>Objectives</h3>
        <ul>
            <li>To provide efficient storage, access, and retrieval of data while ensuring high performance.</li>
            <li>To ensure data integrity, meaning the data remains accurate and consistent over time.</li>
            <li>To eliminate redundancy (repeated data) and inconsistency (conflicting versions of data).</li>
            <li>To support concurrent access by multiple users without data conflicts or loss.</li>
            <li>To provide backup and recovery solutions that protect data in case of failure or disaster.</li>
        </ul>
        
        <h3>Advantages</h3>
        <ul>
            <li><strong>Data Integrity:</strong> A DBMS uses rules and constraints to ensure that the data entered into the database is valid and consistent.</li>
            <li><strong>Security:</strong> Access controls and authentication features protect sensitive data from unauthorized users.</li>
            <li><strong>Reduced Redundancy:</strong> Data is stored in one place and shared across multiple applications, avoiding duplication.</li>
            <li><strong>Efficient Data Access:</strong> Users can retrieve specific data quickly using structured query language (SQL).</li>
            <li><strong>Backup and Recovery:</strong> Automatic tools and processes help recover lost data and restore databases in case of errors or system failures.</li>
        </ul>
        
        <h3>Disadvantages</h3>
        <ul>
            <li><strong>Cost:</strong> Setting up a DBMS requires significant investment in software, hardware, and skilled personnel. Licensing, maintenance, and infrastructure costs can be high, especially for large enterprises.</li>
            <li><strong>Complexity:</strong> Operating and managing a DBMS requires technical expertise. Tasks like database design, query optimization, backup, and recovery demand skilled administrators and developers.</li>
            <li><strong>Performance:</strong> In very large databases, especially those with complex queries or many concurrent users, the overhead of managing data security, integrity, and transactions can slow down performance unless the system is well-optimized.</li>
        </ul>
        
        <h2>Types of Database Model</h2>
        <ul>
            <li><strong>Hierarchical Model:</strong> Organizes data in a tree-like structure where each record has a single parent, and possibly many children. This model is efficient for representing simple one-to-many relationships but becomes difficult to manage when relationships grow more complex.</li>
            <li><strong>Network Model:</strong> More flexible than the hierarchical model, this model allows each record to have multiple parent and child records. It represents complex many-to-many relationships using a graph structure, though it is harder to design and maintain.</li>
            <li><strong>Relational Model:</strong> Stores data in two-dimensional tables with rows and columns. It is the most widely used model due to its simplicity, flexibility, and support for powerful query languages like SQL. Each table can be related to others using keys, making data manipulation efficient.</li>
            <li><strong>Entity-Relational (ER) Model:</strong> Used mainly in database design, the ER model visualizes data as entities (objects), attributes (characteristics), and relationships between them. It helps in understanding data requirements before the actual database is built.</li>
        </ul>
        
        <h2>Integrity Constraints and Types</h2>
        <ul>
            <li><strong>Domain Constraint:</strong> Limits the possible values that an attribute can take. For example, a field "Age" might be restricted to numeric values between 0 and 120, ensuring data validity.</li>
            <li><strong>Entity Integrity:</strong> Ensures that each table has a unique and non-null primary key so that every record can be uniquely identified. Without this, data retrieval and relationship formation become unreliable.</li>
            <li><strong>Referential Integrity:</strong> Maintains consistency among relationships. It ensures that a foreign key value always refers to an existing, valid record in the related table. If not maintained, it could lead to orphaned records or broken links.</li>
        </ul>
        
        <h3>Keys</h3>
        <ul>
            <li><strong>Primary Key:</strong> A unique identifier for each record in a table. No two records can have the same primary key, and it cannot contain null values. It plays a central role in maintaining entity integrity.</li>
            <li><strong>Foreign Key:</strong> An attribute in one table that links to the primary key of another table. It establishes relationships between tables and maintains referential integrity.</li>
            <li><strong>Candidate Key:</strong> A field, or combination of fields, that can uniquely identify a record. A table may have multiple candidate keys, but only one is selected as the primary key.</li>
        </ul>
        
        <h2>Normalization</h2>
        
        <h3>Introduction</h3>
        <p>
        Normalization is a structured process used in database design to minimize data redundancy and ensure logical data storage. It involves dividing large tables into smaller ones and establishing relationships between them. The process follows a series of rules known as Normal Forms. The main goals of normalization are to make data more consistent, reduce duplication, and improve data integrity.
        </p>
        
        <h3>Normal Forms</h3>
        <ul>
            <li><strong>1NF (First Normal Form):</strong> Ensures that each field in a table contains only atomic values (no multiple values or lists) and that each record is unique. It eliminates repeating groups and arrays from the data.</li>
            <li><strong>2NF (Second Normal Form):</strong> Builds upon 1NF by removing partial dependencies, meaning that all non-key attributes must depend on the entire primary key, not just part of it. This usually applies to tables with composite keys.</li>
            <li><strong>3NF (Third Normal Form):</strong> Takes normalization further by eliminating transitive dependencies. A table is in 3NF if it is in 2NF and all non-key attributes are dependent only on the primary key—not on other non-key attributes.</li>
        </ul>
        
        <h3>Advantages</h3>
        <ul>
            <li>Reduces data redundancy and prevents data anomalies during insert, update, or delete operations.</li>
            <li>Improves data accuracy and integrity by ensuring logical data structure and relationships.</li>
            <li>Supports easier maintenance and updates, as changes need to be made in fewer places.</li>
        </ul>
        
        <h3>Disadvantages</h3>
        <ul>
            <li>Over-normalization may lead to too many tables, requiring complex joins that can slow down data retrieval.</li>
            <li>Users may find it harder to write queries or understand the data model due to its fragmented structure.</li>
        </ul>
        
        <h2>Centralized and Distributed Database</h2>
        
        <h3>Introduction</h3>
        <p>
        A centralized database stores all data in a single location, typically a central server, which can be accessed by users over a network. In contrast, a distributed database stores data across multiple physical locations—either different computers in the same area or across geographic regions. These separate locations are connected by a network and work together as if they were a single database. Each model has its own strengths and challenges depending on the scale and nature of use.
        </p>
        
        <h3>Advantages</h3>
        <ul>
            <li><strong>Centralized Database:</strong> Central control over data ensures consistency and simplifies security and management. Backup and recovery processes are easier to handle due to having a single system.</li>
            <li><strong>Distributed Database:</strong> Provides better fault tolerance and improved reliability, as failure in one location doesn't affect the entire system. It also offers faster access for local users and greater scalability as the system grows.</li>
        </ul>
        
        <h3>Disadvantages</h3>
        <ul>
            <li><strong>Centralized Database:</strong> If the central server fails, the entire system becomes inaccessible. Performance may also degrade with increased load or if users are geographically distant from the central location.</li>
            <li><strong>Distributed Database:</strong> Requires more complex system design and management. Issues like data synchronization, network reliability, and security become more challenging across multiple locations.</li>
        </ul>
        
        <h3>Comparison</h3>
        <table border="1" cellspacing="0" cellpadding="10" style="width:100%; border-collapse: collapse;">
            <tr style="background-color:#ffcc5c; color:#000;">
                <th>Feature</th>
                <th>Centralized Database</th>
                <th>Distributed Database</th>
            </tr>
            <tr>
                <td>Location</td>
                <td>All data is stored in a single, centralized location such as a main server or data center.</td>
                <td>Data is spread across multiple physical locations or servers interconnected through a network.</td>
            </tr>
            <tr>
                <td>Data Access Speed</td>
                <td>Faster within the local area or organization due to close proximity to the central server.</td>
                <td>Speed depends on network bandwidth, latency, and connectivity across different locations.</td>
            </tr>
            <tr>
                <td>Failure Risk</td>
                <td>High risk due to a single point of failure. If the central system fails, all data access is lost.</td>
                <td>Low risk as data redundancy allows continued operation even if one site goes down.</td>
            </tr>
            <tr>
                <td>Management</td>
                <td>Easier to manage and control due to centralized policies and configuration.</td>
                <td>Requires complex coordination between sites, with challenges in synchronization and consistency.</td>
            </tr>
        </table>
        
        <h2>Database Security</h2>
        
        <h3>Introduction</h3>
        <p>Database security involves the implementation of policies, procedures, and tools that safeguard the database from cyber threats, internal misuse, unauthorized access, and data breaches. It ensures that sensitive data remains protected and that only authorized users can access or modify the database.</p>
        
        <h3>Challenges</h3>
        <ul>
            <li>Preventing unauthorized access to confidential or sensitive information by implementing strict access controls.</li>
            <li>Mitigating threats such as SQL injection, malware, and phishing attacks which exploit vulnerabilities in poorly secured systems.</li>
            <li>Ensuring compliance with data protection regulations like GDPR, HIPAA, or CCPA, which mandate secure handling and privacy of personal data.</li>
        </ul>
        
        <h3>Security Measures</h3>
        <ul>
            <li><strong>Authentication:</strong> The process of verifying the identity of users through usernames, passwords, biometric scans, or multi-factor authentication before granting database access.</li>
            <li><strong>Authorization:</strong> Defines and controls what actions an authenticated user can perform, based on roles and permissions assigned by the system administrator.</li>
            <li><strong>Encryption:</strong> Converts data into an unreadable format using cryptographic algorithms, making it useless to unauthorized users even if intercepted.</li>
            <li><strong>Audit Trails:</strong> Logs and tracks all activities and changes in the database, allowing detection of unusual or unauthorized behavior for security and compliance audits.</li>
            <li><strong>Backup & Recovery:</strong> Ensures that database copies are regularly saved and can be restored after data loss, corruption, or cyberattacks to maintain business continuity.</li>
        </ul>
        
        <h3>Roles of DBA (Database Administrator)</h3>
        <ul>
            <li><strong>Installation and Configuration:</strong> Sets up the database software, defines the structure, and ensures the system is ready for use.</li>
            <li><strong>Performance Monitoring:</strong> Continuously tracks and improves query response time, storage usage, and system efficiency.</li>
            <li><strong>Security Management:</strong> Implements access controls, roles, and permissions to secure the data and system.</li>
            <li><strong>Data Backup and Recovery:</strong> Plans and executes data backup strategies to prevent data loss, and restores data when necessary.</li>
            <li><strong>Data Integrity Enforcement:</strong> Ensures the data remains accurate, consistent, and reliable through the use of constraints and validation rules.</li>
        </ul>
        
        <h2>Practical Topics</h2>
        
        <h3>DDL and DML Languages</h3>
        <p>SQL is divided into several language components, among which DDL and DML are the most commonly used for managing structure and data respectively.</p>
        
        <p><strong>DDL (Data Definition Language):</strong> DDL commands are used to define or alter the structure of database objects like tables, indexes, and schemas.</p>
        <ul>
            <li><strong>CREATE:</strong> Used to create new tables, databases, views, indexes, or other database objects.</li>
            <li><strong>ALTER:</strong> Allows modification of existing structures, such as adding or removing columns from a table.</li>
            <li><strong>DROP:</strong> Permanently deletes database objects, removing their definitions and data.</li>
        </ul>
        
        <p><strong>DML (Data Manipulation Language):</strong> DML commands deal with data manipulation. They allow users to insert, update, delete, or retrieve data from database tables.</p>
        <ul>
            <li><strong>INSERT:</strong> Adds one or more new records into a table.</li>
            <li><strong>UPDATE:</strong> Modifies existing data in one or more records of a table.</li>
            <li><strong>DELETE:</strong> Removes one or more records from a table.</li>
            <li><strong>SELECT:</strong> Retrieves specific data based on user-defined criteria. It is the most commonly used SQL command.</li>
        </ul>
        
        <h3>SQL Data Types</h3>
        <p>SQL provides a wide range of data types that define the type and size of data that can be stored in a column. Choosing appropriate data types improves data integrity and optimizes storage.</p>
        
<ul>
    <li><strong>CHAR(n):</strong> Fixed-length character string. Stores exactly n characters. If data is shorter, it pads with spaces. Useful for storing codes or fixed-size fields.</li>
    <li><strong>VARCHAR(n):</strong> Variable-length character string. Stores up to n characters without padding. Saves storage space for varying length data like names.</li>
    <li><strong>BINARY(n):</strong> Fixed-length binary data, stores exactly n bytes. Used for raw byte data.</li>
    <li><strong>VARBINARY(n):</strong> Variable-length binary data. Stores up to n bytes without padding.</li>
    <li><strong>TINYBLOB:</strong> Binary Large Object that can store up to 255 bytes of binary data, such as images or multimedia.</li>
    <li><strong>TINYTEXT:</strong> Text data up to 255 characters.</li>
    <li><strong>TEXT:</strong> Larger text field up to 65,535 characters, suitable for descriptions or large notes.</li>
    <li><strong>LONGTEXT:</strong> Very large text data, can store up to 4GB of text.</li>
    <li><strong>ENUM:</strong> Enumeration, allows a column to have one value chosen from a predefined list of strings.</li>
    <li><strong>BIT:</strong> Stores bit-field values (0 or 1), used for boolean flags or binary indicators.</li>
    <li><strong>TINYINT:</strong> Small integer, usually 1 byte (-128 to 127 or 0 to 255 unsigned).</li>
    <li><strong>Boolean:</strong>  Represents a true or false value, often stored internally as 1 (true) or 0 (false), used for binary choices or flags.</li>
    <li><strong>Integer:</strong> Stores whole numbers without decimals, suitable for counts, IDs, or any numeric value that doesn’t require fractions.</li>
    <li><strong>Float:</strong> Stores approximate decimal numbers using floating-point format; good for scientific data where some rounding errors are acceptable.</li>
    <li><strong>Double:</strong> Similar to FLOAT but with double the precision and size, allowing more accurate storage of large or very precise decimal numbers.</li>
    <li><strong>Decimal:</strong> Stores exact fixed-point decimal numbers with a specified total number of digits and digits after the decimal point, perfect for financial and monetary values requiring precision.</li>
    <li><strong>Date:</strong> Stores calendar dates without any time component, typically in a format like YYYY-MM-DD. </li>
    <li><strong>Datetime:</strong> Stores both date and time values together, usually formatted as YYYY-MM-DD HH:MM:SS, useful for timestamps or event tracking.</li>

    </div>

    <div class="footer">
        &copy; All rights reserved. Grade XII Computer Science, 2025.
    </div>
</body>
</html>
